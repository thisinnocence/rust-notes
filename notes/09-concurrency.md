# 09 - 并发编程

本章目标：建立 Rust 并发编程的主心智，并和 C/C++ 对齐。

## 1. 核心结论

- Rust 不是“自动并发正确”，而是“把大量并发误用前置到编译期”。
- 核心抓手是：`Send`/`Sync`、所有权、借用规则、原子内存序。
- 写法上会比 C/C++ 更约束，但长期可维护性通常更高。

## 2. Rust 并发的三层模型

| 层级 | 主要能力 | 常用组件 |
| --- | --- | --- |
| 线程级 | OS 线程并发 | `std::thread` |
| 共享状态级 | 锁与原子 | `Mutex` / `RwLock` / `Atomic*` |
| 任务级 | 协作式并发 | `async/await` + runtime（如 `tokio`） |

## 3. `Send` / `Sync`：并发类型安全的核心

- `Send`：类型的值可以安全地在线程间移动所有权。
- `Sync`：类型的共享引用 `&T` 可以安全地在线程间共享。

直观理解：

- `Send` 解决“能不能跨线程转交这个对象”。
- `Sync` 解决“能不能跨线程共享只读引用”。

这两个 trait 大幅减少“看起来能跑、实则数据竞争”的代码进入运行期。

## 4. 共享可变状态：锁与内部可变性

### 4.1 `Mutex<T>`

- 适合“单写多读都可接受串行化”的场景。
- 基础模型：`Arc<Mutex<T>>` 用于多线程共享可变状态。

### 4.2 `RwLock<T>`

- 读多写少时更合适。
- 需要关注写饥饿与实现差异。

### 4.3 `RefCell<T>` 不等于并发锁

- `RefCell<T>` 是单线程运行时借用检查。
- 多线程要用 `Mutex/RwLock` 或更高层并发结构。

## 5. 消息传递模型：channel

Rust 也常用“共享内存最小化 + 消息传递”策略：

- `std::sync::mpsc`：标准库基础通道。
- `crossbeam` / `tokio::sync`：更丰富或异步场景常用。

工程意义：

- 用 channel 显式表达并发边界，减少锁粒度设计复杂度。

## 6. 原子与内存序

Rust 原子模型与 C/C++11 原子思想一致：

- `Relaxed`
- `Acquire`
- `Release`
- `AcqRel`
- `SeqCst`

建议：

- 默认从 `SeqCst` 起步，先做对，再做快。
- 性能驱动时再降序到 `Acquire/Release/Relaxed`，并配合基准与正确性验证。

## 7. `async` 并发：不是“更快线程”，是“更高并发密度”

- `async/await` 适合 IO 密集与高连接数场景。
- 运行时（如 `tokio`）负责任务调度。
- `await` 点是潜在调度切换点，状态必须能被安全保存与恢复。

常见误区：

- 把 CPU 重任务直接放在 async 任务里不做隔离。
- 在 async 里使用阻塞 API 导致线程池被卡住。

## 8. 对照 C/C++ 并发开发

| 维度 | C/C++ 常见路径 | Rust 常见路径 |
| --- | --- | --- |
| 线程共享 | 人工约束 + 代码审查 | 类型系统先约束（`Send/Sync`） |
| 锁误用 | 运行期暴露更多 | 一部分误用在编译期阻断 |
| 数据竞争 | 依赖工具与规范兜底 | 语言层减少可构造非法状态 |
| 抽象代价 | 前期更快，后期治理成本高 | 前期更慢，后期返工成本常更低 |

## 9. 系统程序员实战建议

- 先选并发模型，再写代码：
- 共享状态（锁）还是消息传递（channel）。
- 优先缩小共享可变状态。
- 把锁持有时间和作用域控制到最小。
- 原子优化要有测量与验证，不建议依赖直觉。
- async 场景先明确“哪些代码允许阻塞，哪些必须非阻塞”。

## 9.1 锁竞争与 lock-free：决策边界

核心结论：

- 不建议把 lock-free 作为默认高性能解法。
- 大多数系统先用“简单锁 + 好的数据分片”更稳、更快落地。

| 选择 | 适用场景 | 风险/代价 |
| --- | --- | --- |
| `Mutex/RwLock` | 业务逻辑复杂、正确性优先 | 高竞争下可能有延迟抖动 |
| 分片锁（sharding） | 热点可按 key 分散 | 设计复杂度上升 |
| lock-free | 极端热点、低延迟刚需 | 正确性证明和调试成本高 |

实战顺序建议：

- 第一步：先测锁竞争是否真是瓶颈。
- 第二步：先尝试分片、减锁粒度、缩短临界区。
- 第三步：只有在收益明确时再进入 lock-free 设计。

结论：

- lock-free 是“最后 20% 优化手段”，不是第一选择。

## 10. 学习路径

- 第一步：`std::thread` + `Arc<Mutex<T>>` 写最小可运行并发示例。
- 第二步：引入 channel，把共享状态改为消息驱动。
- 第三步：学习原子与内存序，做小规模 lock-free 练习。
- 第四步：进入 `tokio`，掌握 async 并发与阻塞隔离。

结论：

- Rust 并发不是“更魔法”，而是“更显式、更可验证”。
