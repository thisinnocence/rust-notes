# 03 - Result 与错误处理

运行：

```bash
cargo run --bin 03_result
```

## 1. `Result<T, E>` 到底是什么

先回答核心问题：

- `Result` 不是关键字（keyword）。
- `Result` 是标准库里的通用枚举类型（在 prelude 里，默认可直接用）。
- 形态是：`Result<T, E>`，其中：
- `T` = 成功值类型（`Ok(T)`）
- `E` = 错误类型（`Err(E)`）

可以把它理解为“必须被处理的成功/失败联合体”。

## 2. `<T, E>` 尖括号语法是什么

- 这是 Rust 泛型参数语法。
- 和 C++ 模板有强相似性：都是“把类型当参数”。
- 可类比：
- Rust `Result<i32, AppError>`
- C++ `Result<int, AppError>`（概念类比）

差异（先记一条就够）：

- Rust 泛型是语言核心 + trait 约束体系，不是头文件模板元编程那套语法风格。

## 3. `?` 运算符到底做了什么

在返回 `Result<..., ...>` 的函数里，`expr?` 等价于：

- 若 `expr` 是 `Ok(v)`，取出 `v` 继续执行。
- 若 `expr` 是 `Err(e)`，立刻 `return Err(...)`。

在本例里：

- `raw.parse()?` 若解析失败，会提前返回错误。
- 因为实现了 `From<ParseIntError> for AppError`，错误会自动转换成 `AppError::Parse`。

可把 `?` 看成“错误路径的早返回语法糖”，减少样板代码。

## 4. 结合本例看错误链

`parse_validate_and_double` 里有三个阶段：

- `parse_i32(raw)?`：字符串转整数
- `require_positive(n)?`：要求大于 0
- `require_even(n)?`：要求是偶数

任意阶段失败，函数立即返回 `Err`；全部通过才 `Ok(n * 2)`。

## 5. 对照 C/C++ 认知

- 类似“返回值 + 错误码”的强化版本，但由类型系统强制处理。
- 相比异常机制，这种方式让错误路径在签名上可见（`-> Result<T, E>`）。
- 相比手写 `if (rc != 0)` 链，`?` 让传播路径简洁很多。

## 6. 工程建议（后续会加）

- 应用层可用 `anyhow` 聚合上下文。
- 库层可用 `thiserror` 定义精确错误类型。

## 7. 深入：为什么 Rust 前期不像 C++ 那样“高速写通”

这个问题本质是“开发节奏模型”差异，不只是语法差异。

### 7.1 C++ 常见节奏

- 先快速把功能写通（允许临时不完美生命周期/错误边界）。
- 再通过测试、工具、审查逐步修内存和并发问题。
- 优点：首版速度快。
- 代价：复杂项目后期返工和隐患排查成本高。

### 7.2 Rust 常见节奏

- 在写第一版时就要明确所有权、借用、错误传播边界。
- 编译器要求“语义先成立”，否则不允许继续。
- 优点：错误前移，后续重构和维护更稳。
- 代价：前期体感变慢，尤其是迁移初期。

### 7.3 为什么 `Result`/`?` 也会让初期看起来更慢

- 必须决定错误模型：错误类型怎么分层、哪些错误向上抛、哪些在本层处理。
- 这比 C++ 里“先 throw/先返回码”多一层设计思考。
- 但一旦模型定好，后续代码一致性会明显提高。

### 7.4 对系统程序员的现实结论

- Rust 不是“写得更快”的语言，而是“更早把语义写正确”的语言。
- 如果只看首版速度，C/C++ 常更快。
- 如果看 6-18 个月维护周期（重构、并发 bug、线上事故），Rust 往往更省。

### 7.5 如何缩短 Rust 前期“变慢期”

- 先统一团队签名习惯：优先 `&T`，确需转移才用 `T`。
- 先统一错误策略：库层精确错误类型，应用层集中包装上下文。
- 对复杂所有权图先降维：用索引/arena 或阶段化处理，避免一开始就写最复杂共享结构。
- 把“编译报错”当设计反馈，不当阻碍；很多报错其实在提示边界不清。
