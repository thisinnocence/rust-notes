# 13 - FFI 入门（Rust <-> C 边界）

本章目标：掌握 Rust 与 C 互调的最小正确姿势。

## 1. FFI 这个术语到底是什么

- FFI = Foreign Function Interface（外部函数接口）。
- 直白理解：让“不同语言编译出来的二进制模块”互相调用函数。
- 在系统编程里，FFI 常用于：
- 在老 C/C++ 系统中逐步引入 Rust 模块。
- 复用已有 C 库（而不是全部重写）。
- 给 Python/Node 等上层语言提供高性能 native 扩展。

背后核心概念是 ABI（Application Binary Interface）：

- API 解决“源码层怎么调用”。
- ABI 解决“二进制层怎么调用”（参数传递、调用约定、符号名、布局等）。
- FFI 本质就是在不同语言之间约定并遵守 ABI。

## 2. 核心结论

- 跨语言边界要用 C ABI：`extern "C"`。
- 要稳定符号名：`#[unsafe(no_mangle)]`。
- 要稳定布局：`#[repr(C)]`。
- 边界函数尽量简单、可审计、可测试。

## 3. 为什么要这三件套

| 机制 | 作用 |
| --- | --- |
| `extern "C"` | 指定调用约定，避免 Rust ABI 假设 |
| `#[unsafe(no_mangle)]` | 保留符号名，方便链接器按名字找函数 |
| `#[repr(C)]` | 结构体布局按 C 规则，避免布局不兼容 |

## 4. 边界设计建议

- 参数优先用 POD 类型（整数、指针、`repr(C)` 结构体）。
- 避免直接把 Rust `String`、`Vec` 暴露给 C。
- 明确内存所有权：谁分配、谁释放。
- 把不安全操作封装在最小边界函数里。

## 5. 错误处理策略

- C ABI 边界常用返回码（`0/-1`）或可判定状态值。
- Rust 内部可保留 `Result`，在边界层转换为 C 可理解协议。

## 6. 和 C/C++ 项目协作时的实践

- 用头文件明确导出函数签名。
- 使用 `cbindgen` 自动生成头文件可减少手工漂移。
- 在 CI 里做跨语言集成测试，防 ABI 回归。

## 7. 一句话总结

- FFI 的重点不是“能调通”，而是“ABI 稳定 + 所有权清楚 + 错误语义清楚”。
