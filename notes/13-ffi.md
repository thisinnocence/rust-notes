# 13 - FFI

本章目标：掌握 Rust 与 C 互调的最小正确姿势。

## 1. FFI 这个术语到底是什么

- FFI = Foreign Function Interface（外部函数接口）。
- 直白理解：让“不同语言编译出来的二进制模块”互相调用函数。
- 在系统编程里，FFI 常用于：
- 在老 C/C++ 系统中逐步引入 Rust 模块。
- 复用已有 C 库（而不是全部重写）。
- 给 Python/Node 等上层语言提供高性能 native 扩展。

背后核心概念是 ABI（Application Binary Interface）：

- API 解决“源码层怎么调用”。
- ABI 解决“二进制层怎么调用”（参数传递、调用约定、符号名、布局等）。
- FFI 本质就是在不同语言之间约定并遵守 ABI。

把“指令级执行流”放到分层里看会更清楚：

- ISA 层：CPU 执行什么指令（x86_64/AArch64 等）。
- ABI 层：函数调用怎么走寄存器/栈、返回值怎么回传。
- API 层：源码里函数怎么声明与调用。

所以，FFI 的位置是：

- 不改变 ISA 执行模型（还是同一套机器指令在跑）。
- 也不改变“函数调用”这个基本执行形态（仍是 call/ret 语义）。
- 它做的是“跨语言函数边界的 ABI 适配与约束”。

## 2. 核心结论

- 跨语言边界要用 C ABI：`extern "C"`。
- 要稳定符号名：`#[unsafe(no_mangle)]`。
- 要稳定布局：`#[repr(C)]`。
- 边界函数尽量简单、可审计、可测试。

## 3. 为什么要这三件套

| 机制 | 作用 |
| --- | --- |
| `extern "C"` | 指定调用约定，避免 Rust ABI 假设 |
| `#[unsafe(no_mangle)]` | 保留符号名，方便链接器按名字找函数 |
| `#[repr(C)]` | 结构体布局按 C 规则，避免布局不兼容 |

## 4. 边界设计建议

- 参数优先用 POD 类型（整数、指针、`repr(C)` 结构体）。
- 避免直接把 Rust `String`、`Vec` 暴露给 C。
- 明确内存所有权：谁分配、谁释放。
- 把不安全操作封装在最小边界函数里。

## 5. 错误处理策略

- C ABI 边界常用返回码（`0/-1`）或可判定状态值。
- Rust 内部可保留 `Result`，在边界层转换为 C 可理解协议。

## 6. 和 C/C++ 项目协作时的实践

- 用头文件明确导出函数签名。
- 使用 `cbindgen` 自动生成头文件可减少手工漂移。
- 在 CI 里做跨语言集成测试，防 ABI 回归。

## 7. 小结

- FFI 的重点不是“能调通”，而是“ABI 稳定 + 所有权清楚 + 错误语义清楚”。

## 8. 没有 runtime/VM 才有价值吗？（对比 Python/C++/Java JNI）

不是“只有无 runtime/无 VM 才有价值”，而是价值来源不同。

| 组合 | FFI 主要价值 | 典型成本/边界 |
| --- | --- | --- |
| Rust <-> C/C++ | 系统级渐进替换、保留低层可控、提升内存安全 | ABI/所有权/错误语义要手工设计 |
| Python <-> C/C++/Rust | 给解释型生态注入性能内核（扩展模块） | GIL、对象模型转换、打包分发复杂度 |
| Java <-> JNI（C/C++/Rust） | JVM 对接 native 能力与遗留库 | JVM/native 边界开销、异常与内存管理双模型 |

该判断可修正为：

- Rust 没有强制 VM/GC runtime，确实让它在系统层 FFI 更“直接可控”。
- 但这不是 FFI 唯一价值来源；有 VM/runtime 的语言同样大量依赖 FFI 获得性能与生态互通。
- 区别在于：Rust/C 场景通常更偏“系统边界与可控性”，Python/Java 更偏“生态扩展与性能热点下沉”。

## 9. 配套代码

对应示例：[`../src/bin/13_ffi.rs`](../src/bin/13_ffi.rs)。

- `#[repr(C)] struct Pair`：稳定布局示例。
- `unsafe extern "C" fn sum_pair(...) -> i32`：C ABI 导出 + 返回码协议。
- 空指针检查体现边界防御。
- 单测覆盖正常路径与空指针路径，作为最小 FFI 验证闭环。
