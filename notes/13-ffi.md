# 13 - FFI 入门（Rust <-> C 边界）

本章目标：掌握 Rust 与 C 互调的最小正确姿势。

## 1. 核心结论

- 跨语言边界要用 C ABI：`extern "C"`。
- 要稳定符号名：`#[unsafe(no_mangle)]`。
- 要稳定布局：`#[repr(C)]`。
- 边界函数尽量简单、可审计、可测试。

## 2. 为什么要这三件套

| 机制 | 作用 |
| --- | --- |
| `extern "C"` | 指定调用约定，避免 Rust ABI 假设 |
| `#[unsafe(no_mangle)]` | 保留符号名，方便链接器按名字找函数 |
| `#[repr(C)]` | 结构体布局按 C 规则，避免布局不兼容 |

## 3. 边界设计建议

- 参数优先用 POD 类型（整数、指针、`repr(C)` 结构体）。
- 避免直接把 Rust `String`、`Vec` 暴露给 C。
- 明确内存所有权：谁分配、谁释放。
- 把不安全操作封装在最小边界函数里。

## 4. 错误处理策略

- C ABI 边界常用返回码（`0/-1`）或可判定状态值。
- Rust 内部可保留 `Result`，在边界层转换为 C 可理解协议。

## 5. 和 C/C++ 项目协作时的实践

- 用头文件明确导出函数签名。
- 使用 `cbindgen` 自动生成头文件可减少手工漂移。
- 在 CI 里做跨语言集成测试，防 ABI 回归。

## 6. 一句话总结

- FFI 的重点不是“能调通”，而是“ABI 稳定 + 所有权清楚 + 错误语义清楚”。
