# 08 - 模块系统（Module System）

这个章节回答一个高频问题：

- Rust 有没有像 C/C++ `namespace` 的东西？
- 如果有，它和 `namespace`、头文件、包管理的关系是什么？

## 1. 一句话结论

- Rust 有“namespace 等价能力”，但不是单点机制。
- Rust 用 `crate + mod + use + pub + path` 组成完整模块系统。

## 2. 核心术语（先建立词典）

- `crate`：一个编译单元（可执行或库），也是最外层命名空间边界。
- `mod`：声明模块，建立层级。
- `use`：把路径引入当前作用域，减少全路径书写。
- `pub`：控制可见性（默认私有）。
- 路径：`crate::a::b::Type`，作用类似 C++ `a::b::Type`。

## 3. 对照 C/C++ 记忆

| 关注点 | C/C++ 常见方式 | Rust 常见方式 |
| --- | --- | --- |
| 名字隔离 | `namespace` | `mod` + 路径 |
| 跨文件声明 | `.h/.hpp` + `.c/.cpp` | 模块树 + 文件组织 |
| 可见性 | `public/private/protected`（类内）+ 其他约定 | `pub`/默认私有（模块级） |
| 导入符号 | `using` / 全限定名 | `use` / 全限定路径 |
| 包边界 | 构建系统与目录约定组合 | `crate`（语言/构建统一） |

## 4. 文件组织的常见约定

Rust 里模块结构通常直接映射文件结构，例如：

```text
src/
├── main.rs      # 二进制 crate 根
├── lib.rs       # 库 crate 根（可选）
└── net/
    ├── mod.rs
    └── tcp.rs
```

也可用更现代的拆分：

```text
src/
├── lib.rs
├── net.rs
└── net/
    └── tcp.rs
```

你可以把它理解为：

- Rust 把“模块关系 + 文件关系 + 构建入口”绑定得更紧。
- 不需要 C/C++ 那种“声明/定义两套文件并行维护”的日常心智。

## 5. `use` 到底在做什么

`use` 只是“引入名字”，不改变所有权语义、不复制对象：

```rust
use crate::net::tcp::Client;
```

它等价于给长路径起一个局部别名，方便写代码。

## 6. 可见性（`pub`）常见规则

- 默认私有：模块外不可见。
- `pub`：向外公开。
- 还可以细分：`pub(crate)`、`pub(super)` 等。

这点对系统项目很重要：

- 你可以主动收缩 API 面，减少跨模块耦合。
- 重构时只要不破坏公开 API，内部实现可自由调整。

## 7. 为什么这比“只有 namespace”更强

如果只有名字隔离，很多工程问题还要靠约定补齐。

Rust 模块系统把这些一起解决：

- 名字空间
- 可见性边界
- 文件组织
- 构建单元（crate）

这也是你会感受到“工程层面更统一”的原因。

## 8. 给 C/C++ 背景的迁移建议

- 先用路径心智：`crate::模块::类型`。
- 再用 `use` 减少样板路径。
- 默认少 `pub`，先做最小可见性。
- 设计 API 时把“模块边界”当成第一层封装，而不是等后期再补。
