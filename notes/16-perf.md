# 16 - 性能分析与优化

本章目标：建立“测量先于优化”的性能工程流程。

## 1. 基本流程

1. 先定义指标（吞吐、P99、CPU、内存、分配次数）。
2. 做基线测量（未优化版本）。
3. 用 profiler 找热点。
4. 做最小改动优化并复测。
5. 若无收益立即回退。

## 2. Rust 常用工具

| 场景 | 工具 |
| --- | --- |
| CPU 热点 | `perf` / `flamegraph` |
| 分配观察 | `heaptrack` / allocator stats |
| 微基准 | `criterion` |
| 编译优化 | `-C opt-level` / LTO / codegen-units |

## 3. 高收益优化方向

- 减少不必要分配（复用 buffer、预分配）。
- 减少拷贝（借用、切片、零拷贝解析）。
- 缩短锁持有时间，降低争用。
- 数据布局友好缓存（连续内存、紧凑结构）。

## 4. 常见误区

- 只看 QPS 不看尾延迟。
- 本地单机结论直接外推生产。
- 提前做复杂 lock-free 而无测量依据。

## 5. 小结

- 性能优化的正确顺序是：先测量，再定位，再优化，再复测。

## 6. 配套代码

对应示例：[`../src/bin/16_perf.rs`](../src/bin/16_perf.rs)。

- 用最小循环求和演示“先拿基线耗时”的动作。
- 重点不是算法本身，而是固定输入、记录耗时、可重复比较。
- 运行：
  - `cargo run --bin 16_perf`
