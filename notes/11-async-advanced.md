# 11 - Async 进阶：Pin / 取消 / 背压

本章目标：从“会写 async”到“能稳定运行 async 系统”。

## 1. Pin/Unpin 是什么

- 某些 `Future` 在轮询过程中不能被移动。
- `Pin` 用来表达“内存位置固定”约束。
- 多数业务代码由编译器和库处理，你需要理解边界而非到处手写 `Pin`。

### 1.1 为什么会和“自引用”扯上关系

- 一旦结构体内部保存“指向自身字段的引用/指针”，移动对象就会让内部引用失效。
- `Pin` 的价值是：对外承诺“这个对象不再被移动”。
- async 状态机内部可能持有跨 `await` 的引用关系，所以 Pin 在 async 底层是核心概念。

### 1.2 常见错误心智

- 误区：`Pin` 只是语法噪音。
- 实际：`Pin` 是“防止非法移动”的类型契约。
- 误区：只要编译过了就无需关心取消与 drop。
- 实际：异步任务被取消时，drop 顺序与资源释放仍要你设计。

## 2. 取消语义

- `Future` 被丢弃即取消。
- 取消不是异常，通常是控制流的一部分。
- 需要确保取消后资源能正确释放与回滚。

## 3. 背压（Backpressure）

- 当生产速度 > 消费速度，系统必须限流或排队。
- 无背压的 async 系统会在高峰期内存暴涨或尾延迟失控。

## 4. 进阶实践

- 统一超时策略（请求级、阶段级）。
- 对外部依赖使用隔离舱（bulkhead）与并发上限。
- 对关键路径做 tracing，观测排队与等待时间。

### 4.1 调度与取消的最小检查单

- 每个任务是否有超时？
- 取消后是否有资源泄漏风险？
- 是否把阻塞代码隔离到专门线程池？
- 是否存在无界队列导致内存膨胀？

## 5. 一句话总结

- async 进阶的核心不是语法，而是“生命周期管理 + 流量控制 + 可观测性”。

## 6. 配套代码怎么读（`src/bin/11_async_advanced.rs`）

- 上半段：`sync_channel` 展示背压与取消信号协作。
- 下半段：手写 `Future`（`DelayTicks`）+ `block_on`，演示 `Pin`/轮询/取消状态。
- 目标是建立底层心智，不是替代 `tokio` 生产实践。

## 7. 工程化模式：timeout / cancellation / shutdown

最小可用模式应同时具备：

- timeout：防止单请求无限等待。
- cancellation：允许任务提前终止。
- shutdown：服务退出时有序收敛在途任务。

## 8. 限流与背压联动

- 限流控制“并发在途数量”（例如 semaphore 思路）。
- 背压控制“生产速度不超过消费能力”（有界队列）。
- 两者配合才能避免高峰期内存和尾延迟失控。

## 9. 配套代码怎么读（`src/bin/11_async_advanced.rs`）

- 有界 `sync_channel`：背压基线。
- `cancelled` 原子标志：取消与 shutdown 信号。
- `recv_timeout`：timeout 风格等待。
- `DelayTicks` + `block_on`：Future/Pin 最小心智。
