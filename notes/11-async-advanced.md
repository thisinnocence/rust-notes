# 11 - 异步进阶：Pin、取消与背压

本章目标：从“会写 async”到“能稳定运行 async 系统”。

## 1. Pin/Unpin 是什么

### 1.1 概念定义（先讲清“它是什么”）

- `Pin` 不是 Rust 关键字，而是标准库类型：`std::pin::Pin<P>`。
- 它是一个“包裹指针的类型约束”：承诺被指向的值在后续不会再被移动。
- 官方文档口径可概括为：`Pin` 用于表达并维护“pointee 不可移动”的语义约束。

### 1.2 设计来源（为什么要有 Pin）

- Rust 的 `async fn` 会编译成状态机；状态机内部可能形成自引用关系。
- 一旦对象被移动，自引用内部地址可能失效，导致未定义行为风险。
- `Pin` 的设计目标就是把“不能移动”变成类型系统可检查的约束。

### 1.3 `Unpin` 是什么关系

- `Unpin` 是 auto trait，表示“该类型即使被 `Pin` 包住也允许移动”。
- 大多数普通类型天然是 `Unpin`，因此日常代码不常直接感知 `Pin`。
- 真正需要 `Pin` 的多是自引用/异步底层类型或手写 `Future` 场景。

### 1.4 在 async 里的位置

- 某些 `Future` 在轮询过程中不能被移动。
- `Pin` 用来表达“内存位置固定”约束。
- 多数业务代码由编译器和库处理，需要理解边界而非到处手写 `Pin`。

### 1.5 为什么会和“自引用”扯上关系

- 一旦结构体内部保存“指向自身字段的引用/指针”，移动对象就会让内部引用失效。
- `Pin` 的价值是：对外承诺“这个对象不再被移动”。
- async 状态机内部可能持有跨 `await` 的引用关系，所以 Pin 在 async 底层是核心概念。

### 1.6 常见错误心智

- 误区：`Pin` 只是语法噪音。
- 实际：`Pin` 是“防止非法移动”的类型契约。
- 误区：只要编译过了就无需关心取消与 drop。
- 实际：异步任务被取消时，drop 顺序与资源释放仍需设计。

## 2. 取消语义

- `Future` 被丢弃即取消。
- 取消不是异常，通常是控制流的一部分。
- 需要确保取消后资源能正确释放与回滚。

## 3. 背压（Backpressure）

- 当生产速度 > 消费速度，系统必须限流或排队。
- 无背压的 async 系统会在高峰期内存暴涨或尾延迟失控。

## 4. 进阶实践

- 统一超时策略（请求级、阶段级）。
- 对外部依赖使用隔离舱（bulkhead）与并发上限。
- 对关键路径做 tracing，观测排队与等待时间。

### 4.1 调度与取消的最小检查单

- 每个任务是否有超时？
- 取消后是否有资源泄漏风险？
- 是否把阻塞代码隔离到专门线程池？
- 是否存在无界队列导致内存膨胀？

## 5. 小结

- async 进阶的核心不是语法，而是“生命周期管理 + 流量控制 + 可观测性”。

## 6. 配套代码

对应示例：[`../src/bin/11_async_advanced.rs`](../src/bin/11_async_advanced.rs)。

- 上半段：有界 `sync_channel` 展示背压与取消信号协作。
- `cancelled` 原子标志：取消与 shutdown 信号。
- `recv_timeout`：timeout 风格等待。
- 下半段：手写 `Future`（`DelayTicks`）+ `block_on`，演示 `Pin`/轮询/取消状态。
- 目标是建立底层心智，不是替代 `tokio` 生产实践。

## 7. 工程化模式：timeout / cancellation / shutdown

最小可用模式应同时具备：

- timeout：防止单请求无限等待。
- cancellation：允许任务提前终止。
- shutdown：服务退出时有序收敛在途任务。

## 8. 限流与背压联动

- 限流控制“并发在途数量”（例如 semaphore 思路）。
- 背压控制“生产速度不超过消费能力”（有界队列）。
- 两者配合才能避免高峰期内存和尾延迟失控。
