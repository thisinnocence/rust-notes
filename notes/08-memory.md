# 08 - 内存模型与布局

本章目标：回答系统程序员最关心的问题。

- Rust 在内存层到底做了什么。
- 编译器做了什么，运行期做了什么。
- 和 C/C++ 在布局、对齐、二进制映射上的差异与边界。

## 1. 核心结论（短版）

- Rust 没有 Go 那种 GC runtime，不会强制接受托管堆模型。
- Rust 默认内存语义更“受约束”：通过类型系统 + 借用规则在编译期防错。
- Rust 可以做和 C 一样的低层二进制处理，但需要显式声明布局与安全前提。

## 2. 编译器做了什么

Rust 编译器在内存相关上主要做这几类事：

| 类别 | Rust 编译期动作 |
| --- | --- |
| 所有权检查 | 确认谁拥有值、何时移动、何时释放 |
| 借用检查 | 确认引用有效期与别名规则（`&`/`&mut`） |
| 布局选择 | 对 `repr(Rust)` 类型可自由优化字段布局（不承诺 C ABI） |
| 优化 | 例如 enum niche optimization、消除不必要拷贝 |
| drop 插桩 | 在作用域结束位置插入析构逻辑（类似 RAII） |

关键点：

- `repr(Rust)` 下，编译器可调整布局以优化性能/大小。
- 需要稳定 ABI/布局时，必须显式用 `#[repr(C)]` 等。

## 3. 运行期做了什么

Rust 运行期（常规 `std` 场景）并不重：

| 项目 | Rust 常规情况 |
| --- | --- |
| GC | 无 |
| 调度器 | 语言无强制调度器（异步库自带执行器是库层能力） |
| 栈管理 | 依赖 OS/ABI 常规机制 |
| 堆分配 | 默认走全局分配器（可替换） |
| panic | 可 `unwind` 或 `abort`，可配置 |

### 3.1 `panic = unwind` 是什么

`unwind` 可理解为“异常回退式退出当前调用栈”：

- 发生 panic 后，不是立刻杀进程。
- 运行时会沿调用栈逐层回退（stack unwinding）。
- 在回退过程中，会执行沿途对象的析构（`Drop`）。
- 若 panic 穿到线程/进程边界且未处理，最终仍会终止程序。

对比 `panic = abort`：

- `abort`：发生 panic 立即终止，不做栈回退，二进制通常更小。
- `unwind`：保留回退能力，资源清理语义更完整，但有额外成本。

系统程序常见选择：

- 对体积、确定性要求高（如裸机/内核早期）：常用 `abort`。
- 需要更完整回退与清理语义的应用层：可用 `unwind`。

对比 Go：

- Go 默认有 GC + runtime 系统组件。
- Rust 默认没有这类强制运行时。

## 4. 结构体布局与对齐（对照 C）

### 4.1 默认布局：`repr(Rust)`

- 字段顺序与填充不承诺和源码完全一致。
- 适合纯 Rust 内部类型，不适合做稳定跨语言 ABI。

### 4.2 C 兼容布局：`#[repr(C)]`

- 让布局和对齐按目标平台 C ABI 规则。
- 适用于 FFI、二进制协议头、与 C 共享结构体。

### 4.3 控制对齐/压缩

- `#[repr(align(N))]`：提高对齐。
- `#[repr(packed)]`：压紧布局，减少 padding。

注意：

- `packed` 字段可能未对齐，直接取引用会触发未定义行为风险。
- 访问 packed 字段通常要用 `read_unaligned` 等方式。

## 5. 会不会“像 Go 一样强制对齐”

该问题可拆成两层：

- Rust 是否有对齐规则：有，且严格。
- Rust 是否像 Go 那样语言级固定一套跨场景内存模型：不是。

更准确地说：

- Rust 对齐遵循目标 ABI 与类型要求。
- 可通过 `repr` 显式声明布局策略。
- 编译器会强约束“引用必须对齐且有效”。

## 6. 能否像 C 一样直接映射二进制并就地解包

可以，但要分“能做”和“安全可做”。

### 6.1 可以做的路径

- `#[repr(C)]` 定义 POD 风格结构。
- 使用 `from_le_bytes`/`from_be_bytes` 处理端序。
- 用 `bytemuck`/`zerocopy` 这类库做受约束转换。

### 6.2 不能偷懒的点

- 不能随意把任意字节切片 `transmute` 成任意结构体。
- 必须确保：
- 对齐满足。
- 大小匹配。
- 字段不含无效 bit pattern。
- 无引用/指针等需要额外有效性条件的字段。

### 6.3 对比 C 的“单字节直白模型”

- C 能更“直接”地做指针强转，但更容易把 UB 带进生产。
- Rust 要求把这些前提显式化，因此写法更啰嗦，但边界更清楚。

## 7. 并发内存模型（简要）

- Rust 原子类型与内存序语义与 C/C++11 原子模型同一类思想（`Relaxed/Acquire/Release/SeqCst`）。
- Rust 在类型层额外用 `Send/Sync` 约束线程共享合法性。
- 不代表“自动无竞态”；而是把很多非法共享在编译期阻断。

## 8. 给系统程序员的落地建议

- 纯 Rust 内部数据：默认 `repr(Rust)`，让编译器优化。
- FFI/协议头/磁盘格式：显式 `repr(C)` + 端序处理 + 尺寸断言。
- 二进制映射优先用成熟库（`zerocopy`/`bytemuck`），少写裸 `unsafe`。
- 仅在必要处使用 `repr(packed)`，并封装未对齐读写。

## 9. 分配器与 Arena：内存管理进阶

### 9.1 全局分配器可替换

- Rust 默认使用系统分配器或目标平台默认配置。
- 可以通过 `#[global_allocator]` 替换为自定义/第三方分配器。

适用场景：

- 需要更稳定尾延迟。
- 需要特定分配统计与调优能力。

### 9.2 Arena/Slab 为什么在系统代码常见

- Arena：批量分配、批量释放，降低碎片和分配开销。
- Slab：固定大小对象池，适合高频同类对象。

对比直接堆分配：

| 模式 | 优势 | 代价 |
| --- | --- | --- |
| 普通堆分配 | 通用、简单 | 高频场景可能抖动与碎片更明显 |
| Arena/Slab | 延迟更可控、局部性更好 | 生命周期管理需额外设计 |

### 9.3 实战建议

- 性能热点先测量再换分配策略。
- 先局部引入 arena，不建议全局一次性替换。
- 把“谁负责释放”写成明确策略，避免内存生命周期失控。

结论：

- Rust 不是放弃低层控制，而是要求把低层前提写清楚、验证清楚。
