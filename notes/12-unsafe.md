# 12 - unsafe 边界

本章目标：不是鼓励“多用 unsafe”，而是强调“把 unsafe 缩到最小且可证明”。

## 1. 核心结论

- `unsafe` 不是关闭安全检查，而是把“这段代码的安全前提”转移到调用方或实现方来证明。
- 好的 Rust 系统代码不是“没有 unsafe”，而是“unsafe 边界小、前提清晰、可测试”。

## 2. 哪些操作需要 unsafe

Rust 里这些典型动作需要 `unsafe`：

- 解引用裸指针（`*const T` / `*mut T`）。
- 调用 `unsafe fn`。
- 访问/修改 `static mut`。
- 实现 `unsafe trait`。
- `union` 字段访问（特定场景）。

## 3. unsafe 设计的三原则

| 原则 | 含义 | 反例 |
| --- | --- | --- |
| 最小化 | 把 unsafe 块缩到最小语句范围 | 整个函数都包在 `unsafe` |
| 封装化 | 用安全 API 包住 unsafe 实现 | 调用方到处写 `unsafe` |
| 可证明 | 写清不变量与前置条件并验证 | “能跑就行”无边界说明 |

## 4. 系统代码常见 unsafe 场景

- MMIO 寄存器读写（裸指针 + volatile）。
- FFI 边界（C ABI 调用）。
- 手写内存池/零拷贝解析器。
- lock-free 结构里的原子与指针操作。

这些都合理，但前提是把约束写清楚。

## 5. 不变量（Invariant）要写什么

每个 unsafe 封装至少说明：

- 地址/指针是否有效。
- 对齐是否满足。
- 生命周期是否覆盖访问期。
- 可变别名是否可能发生。
- 并发访问是否有同步保证。

## 6. 实战模式：安全壳 + 小 unsafe 核心

推荐结构：

- 外层公开安全函数（`pub fn`）。
- 内层私有小函数含 `unsafe`。
- 在 unsafe 块前写“SAFETY 注释”说明理由。

这样评审时可以精准检查风险点，而不是全文件扫描。

## 7. 对比 C/C++ 的思维迁移

- C/C++ 常是“默认不安全，靠经验守纪律”。
- Rust 是“默认安全，显式标记需要人工证明的点”。

迁移建议：

- 把 C 里隐含的前提（对齐、边界、生命周期）写成显式注释与断言。
- unsafe 不是为了“绕过编译器”，而是为了“表达编译器无法自动证明但可由人工证明的事实”。

## 8. 代码评审清单（可直接用）

- unsafe 是否可以再缩小范围？
- 是否存在可替代安全 API？
- SAFETY 注释是否具体、可验证？
- 是否有单测覆盖边界条件？
- 是否有 Miri/sanitizer/fuzz 计划？

## 8.1 unsafe 项目的验证工具链（建议组合使用）

| 工具 | 主要作用 | 适用场景 |
| --- | --- | --- |
| Miri | 解释执行 + UB 检查（借用/别名等） | 指针、生命周期、unsafe 基础验证 |
| Sanitizers | 运行时内存错误检测 | 越界、use-after-free、数据竞争（按工具支持） |
| cargo-fuzz | 随机输入探索边界 | 解析器、协议、二进制处理 |

建议流程：

- 单测先覆盖正常路径。
- Miri 跑关键 unsafe 单测。
- sanitizer 跑集成路径。
- fuzz 持续喂边界输入并固化崩溃样本。

结论：

- unsafe 不靠“自信”保证质量，要靠工具链交叉验证。

## 9. 小结

- unsafe 的质量，决定了系统 Rust 项目的上限。
- 目标不是“零 unsafe”，目标是“可审计、可证明、可维护的 unsafe”。

## 10. 配套代码

对应示例：[`../src/bin/12_unsafe_boundary.rs`](../src/bin/12_unsafe_boundary.rs)。

- 文件顶部给了 `SAFETY TEMPLATE`，可作为后续 unsafe 注释模板。
- `read_u32_unaligned` 展示 `unsafe fn` + 最小危险操作封装。
- `read_u32_le_at` 是安全壳，先做边界检查再进入 unsafe。
- 附带单测覆盖有效路径与越界路径，形成最小验证闭环。
