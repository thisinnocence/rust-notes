# 14 - 生命周期（Lifetime）实战心智

本章目标：把生命周期从“语法恐惧”变成“接口约束工具”。

## 1. 先给结论

- 生命周期不是“对象活多久”，而是“引用在类型系统里被允许使用多久”。
- 大多数生命周期由编译器推断；你只在接口边界不清晰时需要显式标注。

## 2. 典型需要显式标注的场景

| 场景 | 说明 |
| --- | --- |
| 返回引用 | 返回值引用必须与某个输入引用建立关系 |
| 结构体持引用 | 结构体字段是引用时需写生命周期参数 |
| 多输入引用 | 编译器无法判断返回引用来自哪一个输入 |

## 3. 最常见函数签名模式

```rust
fn pick_first<'a>(a: &'a str, _b: &'a str) -> &'a str {
    a
}
```

含义：

- 返回引用的有效期不超过 `'a`。
- `'a` 同时约束输入和输出，表达“输出借用自输入”。

## 4. 结构体持引用的模式

```rust
struct View<'a> {
    s: &'a str,
}
```

含义：

- `View` 不能比 `s` 活得更久。
- 生命周期参数是类型契约，不是运行时字段。

## 5. 对照 C/C++ 心智

- C/C++ 可返回悬垂指针/引用（运行时才炸）。
- Rust 在编译期阻止“返回局部临时引用”这类错误。
- 所以生命周期报错通常在提醒：你的借用关系表达不完整或不成立。

## 6. 处理生命周期报错的步骤

- 先问：返回的引用究竟借用了谁？
- 再问：能否改为返回拥有值（`String`）以简化边界？
- 再考虑：是否需要重构作用域，缩短借用区间？

## 7. 什么时候不要硬上生命周期

- 如果可以返回拥有值，就不要强行返回引用。
- 如果结构体长期持有数据，优先考虑拥有语义而非借用语义。

## 8. 一句话总结

- 生命周期不是负担，而是“把引用关系写进类型系统”的工具。

## 9. 生命周期省略规则（elision）

Rust 常见省略规则（你会频繁遇到）：

- 每个输入引用参数默认有独立生命周期参数。
- 若只有一个输入引用，输出引用默认继承它的生命周期。
- 若是方法且有 `&self`/`&mut self`，输出引用默认与 `self` 关联。

这就是为什么很多函数不写 `'a` 也能通过。

## 10. 返回借用还是返回拥有值（决策模板）

| 场景 | 推荐 |
| --- | --- |
| 返回值依赖输入借用且可零拷贝 | 返回借用（`&str`/`&[T]`） |
| 需要跨作用域长期持有 | 返回拥有值（`String`/`Vec<T>`） |
| 生命周期标注让接口明显复杂 | 优先改为拥有值，先保可维护性 |

## 11. 配套代码怎么读（`src/bin/14_lifetime.rs`）

- `pick_first`：显式生命周期关联输入与输出。
- `pick_first_elided`：演示省略规则与等价写法。
- `View<'a>`：结构体持引用。
- `choose_owned`：演示“返回拥有值”以简化边界。
