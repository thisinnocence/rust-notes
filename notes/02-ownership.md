# 02 - Ownership / Borrow（核心）

运行：

```bash
cargo run --bin 02_ownership
```

## 1. 本章只解决三件事

- Ownership：值在任一时刻只有一个所有者。
- Borrow：可借用值，但不转移所有权。
- Lifetime：借用不能超过被借用值的有效期。

本章聚焦“语义边界”。工程、生态、性能等扩展话题不在这里展开。

## 2. Ownership（所有权）最小规则

- 每个值有且仅有一个所有者。
- 所有者离开作用域时，值被销毁（`drop`）。
- 非 `Copy` 类型在赋值/传参时默认 move。

示例直觉：

- `String` 在赋值给新变量后，原变量不可再使用。
- 基础标量类型（如 `i32`）常是 `Copy`，赋值后原值仍可用。

## 3. Borrow（借用）最小规则

- `&T`：只读借用，可有多个。
- `&mut T`：可写借用，同一时刻只能有一个。
- `&T` 与 `&mut T` 不能在同一时刻并存到同一值上。

这就是“别名与可变性互斥”规则：要么多读，要么独写。

## 4. Lifetime（生命周期）要点

- 生命周期多数可由编译器推断。
- 当返回借用或跨作用域传递借用时，需显式标注边界。
- 报错本质通常是：借用关系在类型层表达不完整。

## 5. 与 C++ 智能指针抽象的详细对比（迁移重点）

先看一张迁移表：

| C++ 抽象 | Rust 对应 | 关键差异 |
| --- | --- | --- |
| `T`（栈对象） | `T`（拥有值） | 都是 RAII；Rust move 默认更强制 |
| `std::unique_ptr<T>` | `Box<T>` | 都是唯一所有权；Rust 不支持“悬空后继续用” |
| `std::shared_ptr<T>` | `Rc<T>` / `Arc<T>` | Rust 显式区分单线程 `Rc` 与多线程 `Arc` |
| `std::weak_ptr<T>` | `Weak<T>` | 都用于打破循环引用 |
| `T&` / `const T&` | `&mut T` / `&T` | Rust 借用有更强编译期别名约束 |
| N/A（运行时借用检查常靠规范） | `RefCell<T>` | Rust 用运行时借用检查换取局部灵活性 |
| `std::mutex` + 智能指针 | `Mutex<T>` + `Arc<T>` | Rust 在类型层约束线程共享边界 |

### 5.1 `unique_ptr` -> `Box`：最平滑

- 都表达“唯一所有者”。
- 都在所有者离开作用域时释放资源。
- 迁移时优先保持“单 owner”设计，通常最自然。

### 5.2 `shared_ptr` -> `Rc/Arc`：先问是否真的需要共享

- Rust 不把共享所有权当默认路径，需要显式选择。
- 单线程共享选 `Rc<T>`，跨线程共享选 `Arc<T>`。
- 和 C++ 一样，循环引用风险仍存在，需要 `Weak<T>` 断环。

### 5.3 “可变共享”在 Rust 里必须显式建模

- C++ 中可通过 `shared_ptr<T>` + 非 const 接口直接修改。
- Rust 中 `Rc<T>`/`Arc<T>` 默认只提供共享只读访问。
- 要共享并可写，需组合：
  - 单线程：`Rc<RefCell<T>>`
  - 多线程：`Arc<Mutex<T>>` 或 `Arc<RwLock<T>>`

这会把“共享可变是有成本的”明确写进类型。

### 5.4 迁移策略（给 C++ 背景）

- 第一步：优先用 `T` / `&T` / `&mut T`，不要一上来就 `Rc/Arc`。
- 第二步：确实需要多 owner 时再引入 `Rc/Arc`。
- 第三步：只有在“共享 + 修改”同时存在时再叠加 `RefCell/Mutex`。

一句话：先单所有权，再共享；先借用，再加指针层。

## 6. RAII / new-delete / GC 的对比（迁移必看）

| 模型 | 释放时机 | 典型风险 | 与 Rust 的关系 |
| --- | --- | --- | --- |
| C 手动管理（`malloc/free`） | 人工调用 `free` | 泄漏、UAF、double free | Rust 把释放责任放入所有权规则，减少人工配对 |
| C++ `new/delete` | 人工 `delete`（或借助 RAII 包装） | 漏删、重复删、异常路径遗漏 | Rust 默认不暴露“裸 delete 流程”给日常代码 |
| C++ RAII（栈对象/智能指针） | 作用域退出自动析构 | 共享可变/别名约束仍需人工 discipline | Rust 把 RAII + 所有权约束做成语言默认 |
| GC 语言（Go/Java 等） | 由 GC 回收器决定 | 回收时机不可精确控制、暂停/吞吐权衡 | Rust 无 GC 运行时，释放时机更可预测 |

### 6.1 和 C++ RAII 的共通点

- 都强调作用域退出时自动清理资源。
- 都鼓励把资源生命周期绑定到对象生命周期。

### 6.2 Rust 相比 C++ RAII 的强化点

- move/借用规则是语言级强制，不依赖团队约定。
- “多读或独写”在类型层表达，不靠代码评审口头约束。
- 默认路径下更少出现 `new/delete` 对应的配对失误类问题。

### 6.3 和 GC 模型的边界

- Rust 不靠 tracing GC 回收对象。
- 对象释放通常在作用域结束时触发，时机可预测。
- 代价是前期需要更明确地建模所有权与借用关系。

## 7. 常见报错应对（Ownership 维度）

- “use of moved value”：
  - 解决：改借用（`&T`/`&mut T`）或显式 `clone`。
- “cannot borrow as mutable”：
  - 解决：缩小不可变借用作用域，或重排代码顺序。
- 生命周期相关错误：
  - 解决：先简化函数签名，再明确返回借用来源。

## 8. 配套代码怎么读（`src/bin/02_ownership.rs`）

- `takes_ownership`：演示 move。
- `borrow_read`：演示不可变借用。
- `borrow_mut`：演示可变借用。
- `clone` 对照：何时复制数据，何时只借用。

## 9. 跨主题内容跳转

- 错误模型（`Result<T, E>`、`?`）：见 `notes/03-result.md`。
- trait/抽象设计：见 `notes/04-trait.md`。
- 构建与生态：见 `notes/05-build.md`。
- FFI 与跨语言边界：见 `notes/13-ffi.md`。
