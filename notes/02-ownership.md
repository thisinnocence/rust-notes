# 02 - Ownership / Borrow（核心）

运行：

```bash
cargo run --bin 02_ownership
```

对照 C/C++：

- `String` move 默认发生在赋值传递时（除非实现 `Copy`）。
- `&T` 类似只读引用，`&mut T` 类似可写引用，但编译器强约束别名规则。
- Rust 在编译期做“借用检查”，避免悬垂、数据竞争等常见问题。

直观理解：

- Ownership = 资源唯一责任人。
- Borrow = 临时借用资源，不转移所有权。
- 生命周期检查 = 编译期证明“借用不会超过被借用值的生存期”。

你可重点对比：

- C++ `std::move` 是显式表达移动；Rust 的 move 更“默认且一致”。
- Rust 没有“野引用侥幸跑通”的空间，很多错误被提前到编译期。

## C++ 背景下的认知映射与纠偏（详细）

### 1. 相似点：为什么你会觉得像

- Rust ownership 和 C++ `unique_ptr` 都强调“唯一所有者”语义。
- Rust move 和 C++ move 语义都意味着“资源责任转移，不做深拷贝”。
- Rust `&T` / `&mut T` 和 C++ 引用在表面语法上都像“别名访问”。
- Rust `drop` 和 C++ RAII 析构都依赖作用域结束触发清理。

这些相似性是有价值的，但只够建立第一层直觉。

### 2. 关键差异：不要把 Rust 当成“语法更严格的 C++”

- C++ 所有权是库/约定层（`unique_ptr/shared_ptr` 等）；Rust 所有权是语言类型系统默认规则。
- C++ move 常需显式 `std::move`；Rust 在赋值/传参时对非 `Copy` 类型默认 move。
- C++ 可以存在别名可变与悬垂风险（取决于写法）；Rust 借用检查在编译期直接禁止这类状态。
- C++ `shared_ptr` 是运行时引用计数共享所有权；Rust 默认不共享所有权，需要显式 `Rc/Arc` 才进入共享模型。

一句话：

- C++ 倾向“你可以做，自己保证正确”。
- Rust 倾向“先证明正确，再允许你做”。

### 3. 最容易出现的认知过度（CPP 迁移常见坑）

- 过度使用“指针/地址”心智：
  - 在 Rust 里优先想“借用关系和生命周期”，不是先想“这个地址怎么传”。
- 以为 `&` 等价 C++ 引用：
  - Rust 的 `&mut` 受排他借用约束，同一时刻不能和其他借用并存。
- 以为 move 后还能“像 C++ 被移动对象那样可用但未指定状态”：
  - Rust move 后原绑定直接不可用（编译错误），规则更硬。
- 试图用“全局可变状态 + 手工同步”开始设计：
  - Rust 更鼓励缩小可变范围、显式建模并发边界。

### 4. 与 C++ 常见机制的对照表（速记）

- `T`（Rust 拥有值）≈ “栈上对象 + RAII 所有权责任”。
- move（Rust 默认转移）≈ C++ `std::move` 后资源转移，但 Rust 更强制。
- `&T`（不可变借用）≈ C++ `const T&` 的只读视角，但生命周期由编译器严格证明。
- `&mut T`（可变借用）≈ “独占可写引用”，比 C++ 非 const 引用限制更强。
- `Rc<T>` ≈ `shared_ptr<T>`（单线程）。
- `Arc<T>` ≈ 线程安全版 `shared_ptr<T>`（原子计数）。
- `RefCell<T>` / `Mutex<T>` ≈ 受控的“运行时可变性检查/互斥”，用于突破静态借用限制的受限工具。

### 5. 建议的迁移心智（给 C++ 老手）

- 第一步先接受：ownership/borrow 不是“技巧”，是主语义。
- 第二步设计函数签名时先问：
  - 这个函数需要拿所有权（`T`）？
  - 只读借用（`&T`）？
  - 可写借用（`&mut T`）？
- 第三步把 `Rc/Arc/RefCell/Mutex` 当作“明确建模成本”的工具，而不是默认选择。
- 第四步遇到借用报错，优先重构数据流和作用域，不要第一反应找“绕过检查”的写法。

## Ownership 的工程权衡：优势、代价与“链表难写”问题

### 1. 你感受到“初期写代码变慢”是正常现象

对有 C/C++ 经验的人，Rust 入门慢通常不是语法慢，而是“语义决策”慢：

- 每个函数都要明确所有权边界（拿走、只读借用、可写借用）。
- 编译器不接受“先写通再慢慢修内存问题”的路径。
- 你会更早面对并发与别名问题，而不是把它留到线上或压力测试阶段。

这会让前 2-6 周体感明显变慢，但它换来的是后期重构和排障成本下降。

### 2. 优势到底来自哪里（高层语义模型）

Ownership/borrow 的本质不是“限制”，而是把程序语义显式化：

- 资源责任显式：谁释放、谁只读、谁可写，不再靠注释和约定。
- 别名与可变性关系显式：减少数据竞争和悬垂引用类问题。
- 错误前移：把一类原本运行期/线上才暴露的问题移到编译期。

从系统工程角度看，它把“内存与并发正确性”从测试阶段前移到建模阶段。

### 3. 代价与痛点：为什么有人说“写个链表都费劲”

这个吐槽有事实基础，尤其在这些场景：

- 自引用结构、双向链表、图结构、侵入式容器。
- 长生命周期别名 + 局部可变更新同时存在。
- 需要跨层共享可变状态（多 owner + mutation）。

原因是这些结构天然挑战“单一所有者 + 借用排他”模型。

Rust 不是不能写，而是要求你明确选择策略：

- 改数据结构：优先 `Vec`/`VecDeque`/索引池（arena）替代裸指针链表。
- 显式共享模型：`Rc/Arc` + `RefCell/Mutex/RwLock`。
- 极端性能或底层场景：在小范围 `unsafe` 内封装不变量。

换句话说，Rust 把“隐式复杂”变成“显式复杂”。

### 4. 对系统程序员的现实建议：什么时候值得、什么时候不值

更值得用 ownership 强约束的场景：

- 长期维护的大型系统代码。
- 并发密集、内存安全风险高的组件。
- 团队协作中“接口语义必须稳定”的基础库。

短期内可能不划算的场景：

- 一次性脚本式 PoC，生命周期极短。
- 团队暂时缺乏 Rust 心智，交付压力又极高。

实践上可采用混合策略：

- 先把高风险核心模块迁移到 Rust。
- 保留稳定 C/C++ 边界，通过 FFI 渐进替换。

### 5. 一个高层判断框架（帮助你做技术决策）

可用下面三问判断是否投入 ownership 建模成本：

- 这段代码会不会长期演进并多次重构？
- 这段代码是否高并发/高内存风险/高可靠性要求？
- 团队是否愿意为“前期慢”交换“后期稳”？

若三问多数为“是”，Rust ownership 通常长期收益更高。

### 6. 认知落点（给 C++ 老手）

- C/C++ 常见路径：先实现能力，再靠测试/规范约束风险。
- Rust 常见路径：先建立正确语义边界，再实现能力。

两者都能做系统软件，但优化目标不同：

- C/C++ 更偏“最快到达可运行”。
- Rust 更偏“更早到达可证明正确的可运行”。
