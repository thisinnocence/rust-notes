# 02 - Ownership / Borrow（核心）

运行：

```bash
cargo run --bin 02_ownership
```

## 1. 本章只解决三件事

- Ownership：值在任一时刻只有一个所有者。
- Borrow：可借用值，但不转移所有权。
- Lifetime：借用不能超过被借用值的有效期。

本章聚焦“语义边界”。工程、生态、性能等扩展话题不在这里展开。

## 2. Ownership（所有权）最小规则

- 每个值有且仅有一个所有者。
- 所有者离开作用域时，值被销毁（`drop`）。
- 非 `Copy` 类型在赋值/传参时默认 move。

示例直觉：

- `String` 在赋值给新变量后，原变量不可再使用。
- 基础标量类型（如 `i32`）常是 `Copy`，赋值后原值仍可用。

## 3. Borrow（借用）最小规则

- `&T`：只读借用，可有多个。
- `&mut T`：可写借用，同一时刻只能有一个。
- `&T` 与 `&mut T` 不能在同一时刻并存到同一值上。

这就是“别名与可变性互斥”规则：要么多读，要么独写。

## 4. Lifetime（生命周期）要点

- 生命周期多数可由编译器推断。
- 当返回借用或跨作用域传递借用时，需显式标注边界。
- 报错本质通常是：借用关系在类型层表达不完整。

## 5. 与 C++ 智能指针抽象的详细对比（迁移重点）

先看一张迁移表：

| C++ 抽象 | Rust 对应 | 关键差异 |
| --- | --- | --- |
| `T`（栈对象） | `T`（拥有值） | 都是 RAII；Rust move 默认更强制 |
| `std::unique_ptr<T>` | `Box<T>` | 都是唯一所有权；Rust 不支持“悬空后继续用” |
| `std::shared_ptr<T>` | `Rc<T>` / `Arc<T>` | Rust 显式区分单线程 `Rc` 与多线程 `Arc` |
| `std::weak_ptr<T>` | `Weak<T>` | 都用于打破循环引用 |
| `T&` / `const T&` | `&mut T` / `&T` | Rust 借用有更强编译期别名约束 |
| N/A（运行时借用检查常靠规范） | `RefCell<T>` | Rust 用运行时借用检查换取局部灵活性 |
| `std::mutex` + 智能指针 | `Mutex<T>` + `Arc<T>` | Rust 在类型层约束线程共享边界 |

### 5.1 `unique_ptr` -> `Box`：迁移成本较低

- 都表达“唯一所有者”。
- 都在所有者离开作用域时释放资源。
- 迁移时优先保持“单 owner”设计，通常最自然。

### 5.2 `shared_ptr` -> `Rc/Arc`：评估是否需要共享

- Rust 不把共享所有权当默认路径，需要显式选择。
- 单线程共享选 `Rc<T>`，跨线程共享选 `Arc<T>`。
- 和 C++ 一样，循环引用风险仍存在，需要 `Weak<T>` 断环。

### 5.3 “可变共享”在 Rust 里必须显式建模

- C++ 中可通过 `shared_ptr<T>` + 非 const 接口直接修改。
- Rust 中 `Rc<T>`/`Arc<T>` 默认只提供共享只读访问。
- 要共享并可写，需组合：
  - 单线程：`Rc<RefCell<T>>`
  - 多线程：`Arc<Mutex<T>>` 或 `Arc<RwLock<T>>`

这会把“共享可变是有成本的”明确写进类型。

### 5.4 迁移策略（给 C++ 背景）

- 第一步：优先用 `T` / `&T` / `&mut T`，不宜一开始就 `Rc/Arc`。
- 第二步：确实需要多 owner 时再引入 `Rc/Arc`。
- 第三步：只有在“共享 + 修改”同时存在时再叠加 `RefCell/Mutex`。

常见迁移顺序：先单所有权，再共享；先借用，再加指针层。

## 6. RAII / new-delete / GC 的对比（迁移对照）

| 模型 | 释放时机 | 典型风险 | 与 Rust 的关系 |
| --- | --- | --- | --- |
| C 手动管理（`malloc/free`） | 人工调用 `free` | 泄漏、UAF、double free | Rust 把释放责任放入所有权规则，减少人工配对 |
| C++ `new/delete` | 人工 `delete`（或借助 RAII 包装） | 漏删、重复删、异常路径遗漏 | Rust 默认不暴露“裸 delete 流程”给日常代码 |
| C++ RAII（栈对象/智能指针） | 作用域退出自动析构 | 共享可变/别名约束仍需人工 discipline | Rust 把 RAII + 所有权约束做成语言默认 |
| GC 语言（Go/Java 等） | 由 GC 回收器决定 | 回收时机不可精确控制、暂停/吞吐权衡 | Rust 无 GC 运行时，释放时机更可预测 |

### 6.1 和 C++ RAII 的共通点

- 都强调作用域退出时自动清理资源。
- 都鼓励把资源生命周期绑定到对象生命周期。

### 6.2 Rust 相比 C++ RAII 的强化点

- move/借用规则是语言级强制，不依赖团队约定。
- “多读或独写”在类型层表达，不靠代码评审口头约束。
- 默认路径下更少出现 `new/delete` 对应的配对失误类问题。

### 6.3 和 GC 模型的边界

- Rust 不靠 tracing GC 回收对象。
- 对象释放通常在作用域结束时触发，时机可预测。
- 代价是前期需要更明确地建模所有权与借用关系。

## 7. Rust 还有手工内存管理与 `unsafe` 吗（简述）

有，但不是默认路径。

- 日常业务代码通常不需要手工管理内存块。
- 在以下场景会进入显式/底层内存管理：
  - FFI 边界（和 C 共享分配/释放约定）
  - 自定义分配器、裸指针数据结构、内存池
  - 内核/驱动/bare-metal 等底层系统代码
- 这些场景常伴随 `unsafe`，并要求把安全前提写成清晰不变量。

本章不展开 `unsafe` 细节，详见 [`notes/12-unsafe.md`](12-unsafe.md)。

### 7.1 Rust 里有哪些“堆内存管理入口”

Rust 没有 `new`/`delete` 关键字，但有明确的类型和库入口：

- `Box<T>`：在堆上分配单个 `T`。
- `Vec<T>` / `String`：可增长容器，内部使用堆分配。
- `Rc<T>` / `Arc<T>`：引用计数对象，控制共享所有权。
- `std::alloc`：底层分配接口（通常只在底层库或 `unsafe` 场景使用）。

`global allocator` 说明：

- 这是 Rust 标准配套机制（语言/标准库生态内建约定），默认已可用。
- 常规程序通常直接使用默认全局分配器，无需手工配置。
- 需要自定义时，可用 `#[global_allocator]` 指定实现。

默认情况下，不直接“手写释放”：

- 对象离开作用域后触发 `drop`。
- `drop` 链路最终把内存归还给分配器。

### 7.2 如何判断“在栈上还是堆上”

可用一个实用规则：

- 值本体是局部变量时，绑定本身通常在栈上。
- 若类型内部含堆分配（`Box`/`Vec`/`String` 等），则“栈上是句柄，数据在堆上”。
- `size_of::<T>()` 只能看到值本体大小，看不到堆上额外容量。

常见例子：

- `let x: i32`：通常只在栈上。
- `let v = Vec::<u8>::new()`：`v` 句柄在栈上，元素缓冲区在堆上。

### 7.3 和 OS 的 `mmap` / `brk` 是什么关系

应用代码通常不会直接调用 `mmap/brk` 来管理普通对象，而是走这条链路：

- Rust 类型（`Box`/`Vec`/`String`）  
-> Rust 分配器接口（global allocator）  
-> 系统分配器实现（如 libc allocator / jemalloc 等）  
-> `mmap`/`brk` 等内核内存机制

关键点：

- 是否用 `mmap`、`brk` 以及何时使用，主要由底层分配器策略决定，不是 Rust 语法直接决定。
- 因平台/分配器不同，行为可能不同；应把它视为“实现细节层”。

## 8. 常见报错应对（Ownership 维度）

- “use of moved value”：
  - 解决：改借用（`&T`/`&mut T`）或显式 `clone`。
- “cannot borrow as mutable”：
  - 解决：缩小不可变借用作用域，或重排代码顺序。
- 生命周期相关错误：
  - 解决：先简化函数签名，再明确返回借用来源。

## 9. 配套代码怎么读（`src/bin/02_ownership.rs`）

- `takes_ownership`：演示 move。
- `borrow_read`：演示不可变借用。
- `borrow_mut`：演示可变借用。
- `clone` 对照：何时复制数据，何时只借用。
