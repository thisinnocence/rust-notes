# 02 - Ownership / Borrow（核心）

运行：

```bash
cargo run --bin 02_ownership
```

## 1. 本章只解决三件事

- Ownership：值在任一时刻只有一个所有者。
- Borrow：可借用值，但不转移所有权。
- Lifetime：借用不能超过被借用值的有效期。

本章聚焦“语义边界”。工程、生态、性能等扩展话题不在这里展开。

## 2. Ownership（所有权）最小规则

- 每个值有且仅有一个所有者。
- 所有者离开作用域时，值被销毁（`drop`）。
- 非 `Copy` 类型在赋值/传参时默认 move。

示例直觉：

- `String` 在赋值给新变量后，原变量不可再使用。
- 基础标量类型（如 `i32`）常是 `Copy`，赋值后原值仍可用。

## 3. Borrow（借用）最小规则

- `&T`：只读借用，可有多个。
- `&mut T`：可写借用，同一时刻只能有一个。
- `&T` 与 `&mut T` 不能在同一时刻并存到同一值上。

这就是“别名与可变性互斥”规则：要么多读，要么独写。

## 4. Lifetime（生命周期）要点

- 生命周期多数可由编译器推断。
- 当返回借用或跨作用域传递借用时，需显式标注边界。
- 报错本质通常是：借用关系在类型层表达不完整。

## 5. 与 C/C++ 的最小映射（只保留本章相关）

- Rust `T`（拥有值）可类比“RAII 所有权责任”。
- Rust move 语义可类比 C++ move，但 Rust 默认更强制。
- Rust `&T` / `&mut T` 可类比只读/可写引用，但借用规则更严格。

一句话：C/C++ 更依赖约定，Rust 更依赖编译期证明。

## 6. 常见报错应对（Ownership 维度）

- “use of moved value”：
  - 解决：改借用（`&T`/`&mut T`）或显式 `clone`。
- “cannot borrow as mutable”：
  - 解决：缩小不可变借用作用域，或重排代码顺序。
- 生命周期相关错误：
  - 解决：先简化函数签名，再明确返回借用来源。

## 7. 配套代码怎么读（`src/bin/02_ownership.rs`）

- `takes_ownership`：演示 move。
- `borrow_read`：演示不可变借用。
- `borrow_mut`：演示可变借用。
- `clone` 对照：何时复制数据，何时只借用。
