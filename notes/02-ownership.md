# 02 - Ownership / Borrow（核心）

运行：

```bash
cargo run --bin 02_ownership
```

对照 C/C++：

- `String` move 默认发生在赋值传递时（除非实现 `Copy`）。
- `&T` 类似只读引用，`&mut T` 类似可写引用，但编译器强约束别名规则。
- Rust 在编译期做“借用检查”，避免悬垂、数据竞争等常见问题。

直观理解：

- Ownership = 资源唯一责任人。
- Borrow = 临时借用资源，不转移所有权。
- 生命周期检查 = 编译期证明“借用不会超过被借用值的生存期”。

你可重点对比：

- C++ `std::move` 是显式表达移动；Rust 的 move 更“默认且一致”。
- Rust 没有“野引用侥幸跑通”的空间，很多错误被提前到编译期。

## C++ 背景下的认知映射与纠偏（详细）

### 1. 相似点：为什么你会觉得像

- Rust ownership 和 C++ `unique_ptr` 都强调“唯一所有者”语义。
- Rust move 和 C++ move 语义都意味着“资源责任转移，不做深拷贝”。
- Rust `&T` / `&mut T` 和 C++ 引用在表面语法上都像“别名访问”。
- Rust `drop` 和 C++ RAII 析构都依赖作用域结束触发清理。

这些相似性是有价值的，但只够建立第一层直觉。

### 2. 关键差异：不要把 Rust 当成“语法更严格的 C++”

- C++ 所有权是库/约定层（`unique_ptr/shared_ptr` 等）；Rust 所有权是语言类型系统默认规则。
- C++ move 常需显式 `std::move`；Rust 在赋值/传参时对非 `Copy` 类型默认 move。
- C++ 可以存在别名可变与悬垂风险（取决于写法）；Rust 借用检查在编译期直接禁止这类状态。
- C++ `shared_ptr` 是运行时引用计数共享所有权；Rust 默认不共享所有权，需要显式 `Rc/Arc` 才进入共享模型。

一句话：

- C++ 倾向“你可以做，自己保证正确”。
- Rust 倾向“先证明正确，再允许你做”。

### 3. 最容易出现的认知过度（CPP 迁移常见坑）

- 过度使用“指针/地址”心智：
  - 在 Rust 里优先想“借用关系和生命周期”，不是先想“这个地址怎么传”。
- 以为 `&` 等价 C++ 引用：
  - Rust 的 `&mut` 受排他借用约束，同一时刻不能和其他借用并存。
- 以为 move 后还能“像 C++ 被移动对象那样可用但未指定状态”：
  - Rust move 后原绑定直接不可用（编译错误），规则更硬。
- 试图用“全局可变状态 + 手工同步”开始设计：
  - Rust 更鼓励缩小可变范围、显式建模并发边界。

### 4. 与 C++ 常见机制的对照表（速记）

- `T`（Rust 拥有值）≈ “栈上对象 + RAII 所有权责任”。
- move（Rust 默认转移）≈ C++ `std::move` 后资源转移，但 Rust 更强制。
- `&T`（不可变借用）≈ C++ `const T&` 的只读视角，但生命周期由编译器严格证明。
- `&mut T`（可变借用）≈ “独占可写引用”，比 C++ 非 const 引用限制更强。
- `Rc<T>` ≈ `shared_ptr<T>`（单线程）。
- `Arc<T>` ≈ 线程安全版 `shared_ptr<T>`（原子计数）。
- `RefCell<T>` / `Mutex<T>` ≈ 受控的“运行时可变性检查/互斥”，用于突破静态借用限制的受限工具。

### 5. 建议的迁移心智（给 C++ 老手）

- 第一步先接受：ownership/borrow 不是“技巧”，是主语义。
- 第二步设计函数签名时先问：
  - 这个函数需要拿所有权（`T`）？
  - 只读借用（`&T`）？
  - 可写借用（`&mut T`）？
- 第三步把 `Rc/Arc/RefCell/Mutex` 当作“明确建模成本”的工具，而不是默认选择。
- 第四步遇到借用报错，优先重构数据流和作用域，不要第一反应找“绕过检查”的写法。
