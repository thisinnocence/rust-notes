# Rust 学习计划

## 学习策略

目标: 同时追求学习速度和长期记忆, 用 AI 做加速器, 不做替代器

每次练习流程:

1. 先和 AI 明确需求场景, 输入输出, 约束和边界
2. AI 只给知识点解释和最小示例, 不给完整作业答案
3. 自己独立编码 10-20 分钟, 先写出第一版
4. 卡住再问 AI, 只看当前卡点的最小提示
5. 关闭参考, 从空白重写并跑通
6. 用自己的话解释 Why, 包括设计理由 报错原因 修复路径
7. 当天复盘 3 个新概念 + 1 个易错点 + 1 个迁移到 C++/Go/TS 的类比

执行规则:

- AI 是教练和审稿人, 不是代写者
- 每次学习必须有一段无参考纯手写
- 默认不看完整答案, 只有明确请求时才看
- 完成标准是 可运行 + 可解释 + 可复写

TIP:

- 只看 AI 代码并“看懂”, 常会产生熟悉感错觉 fluency illusion, 不等于可独立复现
- 先自己写再看答案, 本质是主动回忆 + 生成效应, 记忆痕迹更深
- 卡点后只看最小提示, 能保持适度困难, 更容易形成可迁移能力
- 关闭参考重写, 相当于一次检索练习, 比重复阅读更能巩固长期记忆
- 动手编码会同时调用概念通路 + 动作程序通路, 属于多通道编码, 保留率通常高于纯阅读
- 当天复盘和第二天再做一遍, 属于间隔复习, 能显著降低遗忘速度

PS: 根据脑科学原理：

学习时先独立写, 再看最小提示, 再关掉参考重写并口头讲解, 之所以有效是因为它同时触发了主动回忆 retrieval practice 与生成效应 generation effect, 比被动阅读更能强化可提取记忆, 再配合隔天回顾形成间隔复习 spaced repetition, 可显著降低遗忘并提升迁移能力, 其中“说出声”还叠加了生产效应 production effect 与自我解释 self explanation, 通过语言输出进一步暴露理解漏洞并加深记忆编码, 这也是为什么只看 AI 代码容易产生“看懂了”的熟悉感错觉, 但动手与讲解才更接近真正掌握。

方法得当的学习，对于有 C++ Go TS 基础的资深程序员，通常 1-2 周可以完成 Rust 核心语法与工程流上手，4-8 周可以把所有权 借用 生命周期 并发模型内化到日常编码，关键不在“看过多少材料”，而在“完成了多少次可运行 可解释 可复写的闭环练习”。

## Day 1 基础语法与工具链

- ✅ Cargo 默认目标发现规则: `src/main.rs` `src/lib.rs` `src/bin/*.rs`
- ✅ 非默认路径目标配置: `[[bin]]` + `path`
- ✅ 数组与切片: `[T; N]` `&arr[start..end]` 左闭右开
- ✅ borrow 语义: 切片是借用视图, 不会 copy
- ✅ `Vec` 动态数组基础与 `clone` 深拷贝
- ✅ `Box` 与堆分配概念
- ✅ `Rc` 共享所有权与引用计数
- ✅ 代码风格与工具: `cargo fmt` `cargo fmt --check`

## Day 2 结构体 枚举 模式匹配

- ⬜ `struct` 与方法 `impl`
- ⬜ `enum` + `match` 穷尽匹配
- ⬜ `Option` `Result` 组合使用
- ⬜ 生命周期标注基础: 函数签名中的 `'a` 与借用关系 (🟥 高频难点)
- ⬜ 练习: 状态机小例子

## Day 3 错误处理

- ⬜ `Result<T, E>` 设计
- ⬜ `?` 运算符与错误传播
- ⬜ 自定义错误类型
- ⬜ 练习: CLI 输入解析与分层报错

## Day 4 集合与字符串

- ⬜ `Vec` `HashMap` `BTreeMap` 适用场景
- ⬜ `String` 与 `&str` 区别
- ⬜ 迭代器管道 `map/filter/collect`
- ⬜ 练习: 小型数据处理程序

## Day 5 trait 与泛型

- ⬜ trait 基础与实现
- ⬜ 泛型函数与泛型结构体
- ⬜ `impl Trait` 与 `dyn Trait` (🟧 进阶难点)
- ⬜ 练习: 可替换后端接口

## Day 6 并发基础

- ⬜ `thread` 与 `move`
- ⬜ `Arc<Mutex<T>>` (🟥 高频难点)
- ⬜ `mpsc` 通道通信
- ⬜ `async fn` `Future` `await` 基础 (🟥 高频难点)
- ⬜ runtime 概念与 Tokio 入门 (🟥 高频难点)
- ⬜ `spawn` `join` `select` 基本模式 (🟧 进阶难点)
- ⬜ 练习: 多线程计数器与任务分发

## Day 7 模块与工程化

- ⬜ 模块拆分与 `pub` 可见性
- ⬜ package crate workspace 关系
- ⬜ fmt clippy test 的 CI 基线
- ⬜ 练习: 把 demo 拆成多模块并加测试

## Day 8: 大作业

- ⬜ 能从空白实现一个含 CRUD 的 CLI
- ⬜ 能解释 `Vec` `Box` `Rc` 的差异与适用场景
- ⬜ 能修复常见 borrow checker 报错 (🟥 高频难点)
- ⬜ 能用 `cargo fmt` `clippy` `test` 跑完整流程
- ⬜ 能实现一个最小异步任务聚合 demo
